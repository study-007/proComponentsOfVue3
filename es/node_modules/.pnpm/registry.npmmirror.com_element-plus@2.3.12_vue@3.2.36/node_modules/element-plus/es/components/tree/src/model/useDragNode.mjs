import { ref as C, provide as I } from "vue";
import { useNamespace as E } from "../../../../hooks/use-namespace/index.mjs";
import { removeClass as N, addClass as P } from "../../../../utils/dom/style.mjs";
const B = Symbol("dragEvents");
function K({ props: p, ctx: s, el$: h, dropIndicator$: b, store: $ }) {
  const g = E("tree"), d = C({
    showDropIndicator: !1,
    draggingNode: null,
    dropNode: null,
    allowDrop: !0,
    dropType: null
  });
  return I(B, {
    treeNodeDragStart: ({ event: r, treeNode: t }) => {
      if (typeof p.allowDrag == "function" && !p.allowDrag(t.node))
        return r.preventDefault(), !1;
      r.dataTransfer.effectAllowed = "move";
      try {
        r.dataTransfer.setData("text/plain", "");
      } catch {
      }
      d.value.draggingNode = t, s.emit("node-drag-start", t.node, r);
    },
    treeNodeDragOver: ({ event: r, treeNode: t }) => {
      const e = t, o = d.value.dropNode;
      o && o.node.id !== e.node.id && N(o.$el, g.is("drop-inner"));
      const n = d.value.draggingNode;
      if (!n || !e)
        return;
      let i = !0, l = !0, f = !0, m = !0;
      typeof p.allowDrop == "function" && (i = p.allowDrop(n.node, e.node, "prev"), m = l = p.allowDrop(n.node, e.node, "inner"), f = p.allowDrop(n.node, e.node, "next")), r.dataTransfer.dropEffect = l || i || f ? "move" : "none", (i || l || f) && (o == null ? void 0 : o.node.id) !== e.node.id && (o && s.emit("node-drag-leave", n.node, o.node, r), s.emit("node-drag-enter", n.node, e.node, r)), (i || l || f) && (d.value.dropNode = e), e.node.nextSibling === n.node && (f = !1), e.node.previousSibling === n.node && (i = !1), e.node.contains(n.node, !1) && (l = !1), (n.node === e.node || n.node.contains(e.node)) && (i = !1, l = !1, f = !1);
      const u = e.$el.querySelector(`.${g.be("node", "content")}`).getBoundingClientRect(), c = h.value.getBoundingClientRect();
      let a;
      const T = i ? l ? 0.25 : f ? 0.45 : 1 : -1, S = f ? l ? 0.75 : i ? 0.55 : 0 : 1;
      let D = -9999;
      const w = r.clientY - u.top;
      w < u.height * T ? a = "before" : w > u.height * S ? a = "after" : l ? a = "inner" : a = "none";
      const v = e.$el.querySelector(`.${g.be("node", "expand-icon")}`).getBoundingClientRect(), y = b.value;
      a === "before" ? D = v.top - c.top : a === "after" && (D = v.bottom - c.top), y.style.top = `${D}px`, y.style.left = `${v.right - c.left}px`, a === "inner" ? P(e.$el, g.is("drop-inner")) : N(e.$el, g.is("drop-inner")), d.value.showDropIndicator = a === "before" || a === "after", d.value.allowDrop = d.value.showDropIndicator || m, d.value.dropType = a, s.emit("node-drag-over", n.node, e.node, r);
    },
    treeNodeDragEnd: (r) => {
      const { draggingNode: t, dropType: e, dropNode: o } = d.value;
      if (r.preventDefault(), r.dataTransfer.dropEffect = "move", t && o) {
        const n = { data: t.node.data };
        e !== "none" && t.node.remove(), e === "before" ? o.node.parent.insertBefore(n, o.node) : e === "after" ? o.node.parent.insertAfter(n, o.node) : e === "inner" && o.node.insertChild(n), e !== "none" && $.value.registerNode(n), N(o.$el, g.is("drop-inner")), s.emit("node-drag-end", t.node, o.node, e, r), e !== "none" && s.emit("node-drop", t.node, o.node, e, r);
      }
      t && !o && s.emit("node-drag-end", t.node, null, e, r), d.value.showDropIndicator = !1, d.value.draggingNode = null, d.value.dropNode = null, d.value.allowDrop = !0;
    }
  }), {
    dragState: d
  };
}
export {
  B as dragEventsKey,
  K as useDragNodeHandler
};

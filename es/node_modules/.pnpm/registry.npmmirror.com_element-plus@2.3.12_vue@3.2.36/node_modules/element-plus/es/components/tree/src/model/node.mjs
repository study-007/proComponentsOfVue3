import { reactive as v } from "vue";
import { markNodeData as C, NODE_KEY as y } from "./util.mjs";
import { hasOwn as D } from "../../../../../../../../registry.npmmirror.com_@vue_shared@3.3.4/node_modules/@vue/shared/dist/shared.esm-bundler.mjs";
const N = (r) => {
  let e = !0, t = !0, s = !0;
  for (let i = 0, a = r.length; i < a; i++) {
    const h = r[i];
    (h.checked !== !0 || h.indeterminate) && (e = !1, h.disabled || (s = !1)), (h.checked !== !1 || h.indeterminate) && (t = !1);
  }
  return { all: e, none: t, allWithoutDisable: s, half: !e && !t };
}, o = function(r) {
  if (r.childNodes.length === 0 || r.loading)
    return;
  const { all: e, none: t, half: s } = N(r.childNodes);
  e ? (r.checked = !0, r.indeterminate = !1) : s ? (r.checked = !1, r.indeterminate = !0) : t && (r.checked = !1, r.indeterminate = !1);
  const i = r.parent;
  !i || i.level === 0 || r.store.checkStrictly || o(i);
}, l = function(r, e) {
  const t = r.store.props, s = r.data || {}, i = t[e];
  if (typeof i == "function")
    return i(s, r);
  if (typeof i == "string")
    return s[i];
  if (typeof i > "u") {
    const a = s[e];
    return a === void 0 ? "" : a;
  }
};
let L = 0;
class f {
  constructor(e) {
    this.id = L++, this.text = null, this.checked = !1, this.indeterminate = !1, this.data = null, this.expanded = !1, this.parent = null, this.visible = !0, this.isCurrent = !1, this.canFocus = !1;
    for (const t in e)
      D(e, t) && (this[t] = e[t]);
    this.level = 0, this.loaded = !1, this.childNodes = [], this.loading = !1, this.parent && (this.level = this.parent.level + 1);
  }
  initialize() {
    const e = this.store;
    if (!e)
      throw new Error("[Node]store is required!");
    e.registerNode(this);
    const t = e.props;
    if (t && typeof t.isLeaf < "u") {
      const a = l(this, "isLeaf");
      typeof a == "boolean" && (this.isLeafByUser = a);
    }
    if (e.lazy !== !0 && this.data ? (this.setData(this.data), e.defaultExpandAll && (this.expanded = !0, this.canFocus = !0)) : this.level > 0 && e.lazy && e.defaultExpandAll && this.expand(), Array.isArray(this.data) || C(this, this.data), !this.data)
      return;
    const s = e.defaultExpandedKeys, i = e.key;
    i && s && s.includes(this.key) && this.expand(null, e.autoExpandParent), i && e.currentNodeKey !== void 0 && this.key === e.currentNodeKey && (e.currentNode = this, e.currentNode.isCurrent = !0), e.lazy && e._initDefaultCheckedNode(this), this.updateLeafState(), this.parent && (this.level === 1 || this.parent.expanded === !0) && (this.canFocus = !0);
  }
  setData(e) {
    Array.isArray(e) || C(this, e), this.data = e, this.childNodes = [];
    let t;
    this.level === 0 && Array.isArray(this.data) ? t = this.data : t = l(this, "children") || [];
    for (let s = 0, i = t.length; s < i; s++)
      this.insertChild({ data: t[s] });
  }
  get label() {
    return l(this, "label");
  }
  get key() {
    const e = this.store.key;
    return this.data ? this.data[e] : null;
  }
  get disabled() {
    return l(this, "disabled");
  }
  get nextSibling() {
    const e = this.parent;
    if (e) {
      const t = e.childNodes.indexOf(this);
      if (t > -1)
        return e.childNodes[t + 1];
    }
    return null;
  }
  get previousSibling() {
    const e = this.parent;
    if (e) {
      const t = e.childNodes.indexOf(this);
      if (t > -1)
        return t > 0 ? e.childNodes[t - 1] : null;
    }
    return null;
  }
  contains(e, t = !0) {
    return (this.childNodes || []).some((s) => s === e || t && s.contains(e));
  }
  remove() {
    const e = this.parent;
    e && e.removeChild(this);
  }
  insertChild(e, t, s) {
    if (!e)
      throw new Error("InsertChild error: child is required.");
    if (!(e instanceof f)) {
      if (!s) {
        const i = this.getChildren(!0);
        i.includes(e.data) || (typeof t > "u" || t < 0 ? i.push(e.data) : i.splice(t, 0, e.data));
      }
      Object.assign(e, {
        parent: this,
        store: this.store
      }), e = v(new f(e)), e instanceof f && e.initialize();
    }
    e.level = this.level + 1, typeof t > "u" || t < 0 ? this.childNodes.push(e) : this.childNodes.splice(t, 0, e), this.updateLeafState();
  }
  insertBefore(e, t) {
    let s;
    t && (s = this.childNodes.indexOf(t)), this.insertChild(e, s);
  }
  insertAfter(e, t) {
    let s;
    t && (s = this.childNodes.indexOf(t), s !== -1 && (s += 1)), this.insertChild(e, s);
  }
  removeChild(e) {
    const t = this.getChildren() || [], s = t.indexOf(e.data);
    s > -1 && t.splice(s, 1);
    const i = this.childNodes.indexOf(e);
    i > -1 && (this.store && this.store.deregisterNode(e), e.parent = null, this.childNodes.splice(i, 1)), this.updateLeafState();
  }
  removeChildByData(e) {
    let t = null;
    for (let s = 0; s < this.childNodes.length; s++)
      if (this.childNodes[s].data === e) {
        t = this.childNodes[s];
        break;
      }
    t && this.removeChild(t);
  }
  expand(e, t) {
    const s = () => {
      if (t) {
        let i = this.parent;
        for (; i.level > 0; )
          i.expanded = !0, i = i.parent;
      }
      this.expanded = !0, e && e(), this.childNodes.forEach((i) => {
        i.canFocus = !0;
      });
    };
    this.shouldLoadData() ? this.loadData((i) => {
      Array.isArray(i) && (this.checked ? this.setChecked(!0, !0) : this.store.checkStrictly || o(this), s());
    }) : s();
  }
  doCreateChildren(e, t = {}) {
    e.forEach((s) => {
      this.insertChild(Object.assign({ data: s }, t), void 0, !0);
    });
  }
  collapse() {
    this.expanded = !1, this.childNodes.forEach((e) => {
      e.canFocus = !1;
    });
  }
  shouldLoadData() {
    return this.store.lazy === !0 && this.store.load && !this.loaded;
  }
  updateLeafState() {
    if (this.store.lazy === !0 && this.loaded !== !0 && typeof this.isLeafByUser < "u") {
      this.isLeaf = this.isLeafByUser;
      return;
    }
    const e = this.childNodes;
    if (!this.store.lazy || this.store.lazy === !0 && this.loaded === !0) {
      this.isLeaf = !e || e.length === 0;
      return;
    }
    this.isLeaf = !1;
  }
  setChecked(e, t, s, i) {
    if (this.indeterminate = e === "half", this.checked = e === !0, this.store.checkStrictly)
      return;
    if (!(this.shouldLoadData() && !this.store.checkDescendants)) {
      const { all: h, allWithoutDisable: n } = N(this.childNodes);
      !this.isLeaf && !h && n && (this.checked = !1, e = !1);
      const c = () => {
        if (t) {
          const d = this.childNodes;
          for (let u = 0, x = d.length; u < x; u++) {
            const p = d[u];
            i = i || e !== !1;
            const m = p.disabled ? p.checked : i;
            p.setChecked(m, t, !0, i);
          }
          const { half: k, all: g } = N(d);
          g || (this.checked = g, this.indeterminate = k);
        }
      };
      if (this.shouldLoadData()) {
        this.loadData(() => {
          c(), o(this);
        }, {
          checked: e !== !1
        });
        return;
      } else
        c();
    }
    const a = this.parent;
    !a || a.level === 0 || s || o(a);
  }
  getChildren(e = !1) {
    if (this.level === 0)
      return this.data;
    const t = this.data;
    if (!t)
      return null;
    const s = this.store.props;
    let i = "children";
    return s && (i = s.children || "children"), t[i] === void 0 && (t[i] = null), e && !t[i] && (t[i] = []), t[i];
  }
  updateChildren() {
    const e = this.getChildren() || [], t = this.childNodes.map((a) => a.data), s = {}, i = [];
    e.forEach((a, h) => {
      const n = a[y];
      !!n && t.findIndex((d) => d[y] === n) >= 0 ? s[n] = { index: h, data: a } : i.push({ index: h, data: a });
    }), this.store.lazy || t.forEach((a) => {
      s[a[y]] || this.removeChildByData(a);
    }), i.forEach(({ index: a, data: h }) => {
      this.insertChild({ data: h }, a);
    }), this.updateLeafState();
  }
  loadData(e, t = {}) {
    if (this.store.lazy === !0 && this.store.load && !this.loaded && (!this.loading || Object.keys(t).length)) {
      this.loading = !0;
      const s = (i) => {
        this.childNodes = [], this.doCreateChildren(i, t), this.loaded = !0, this.loading = !1, this.updateLeafState(), e && e.call(this, i);
      };
      this.store.load(this, s);
    } else
      e && e.call(this);
  }
}
export {
  f as default,
  N as getChildState
};

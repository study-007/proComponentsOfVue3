import { defineComponent as U, ref as u, computed as G, watch as c, provide as N, getCurrentInstance as J, resolveComponent as Q, openBlock as y, createElementBlock as f, normalizeClass as h, Fragment as W, renderList as X, createBlock as Y, renderSlot as Z, createElementVNode as C, toDisplayString as _, createCommentVNode as ee, withDirectives as te, vShow as ne } from "vue";
import re from "./model/tree-store.mjs";
import { getNodeKey as oe, handleCurrentChange as k } from "./model/util.mjs";
import de from "./tree-node.mjs";
import { useNodeExpandEventBroadcast as ae } from "./model/useNodeExpandEventBroadcast.mjs";
import { useDragNodeHandler as le } from "./model/useDragNode.mjs";
import { useKeydown as se } from "./model/useKeydown.mjs";
import ue from "../../../_virtual/plugin-vue_export-helper.mjs";
import { iconPropType as ce } from "../../../utils/vue/icon.mjs";
import { useLocale as ie } from "../../../hooks/use-locale/index.mjs";
import { useNamespace as ye } from "../../../hooks/use-namespace/index.mjs";
import { formItemContextKey as he } from "../../form/src/constants.mjs";
const fe = U({
  name: "ElTree",
  components: { ElTreeNode: de },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String
    },
    renderAfterExpand: {
      type: Boolean,
      default: !0
    },
    nodeKey: String,
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: !0
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: !1
    },
    autoExpandParent: {
      type: Boolean,
      default: !0
    },
    defaultCheckedKeys: Array,
    defaultExpandedKeys: Array,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: !1
    },
    draggable: {
      type: Boolean,
      default: !1
    },
    allowDrag: Function,
    allowDrop: Function,
    props: {
      type: Object,
      default: () => ({
        children: "children",
        label: "label",
        disabled: "disabled"
      })
    },
    lazy: {
      type: Boolean,
      default: !1
    },
    highlightCurrent: Boolean,
    load: Function,
    filterNodeMethod: Function,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    icon: {
      type: ce
    }
  },
  emits: [
    "check-change",
    "current-change",
    "node-click",
    "node-contextmenu",
    "node-collapse",
    "node-expand",
    "check",
    "node-drag-start",
    "node-drag-end",
    "node-drop",
    "node-drag-leave",
    "node-drag-enter",
    "node-drag-over"
  ],
  setup(e, d) {
    const { t: m } = ie(), g = ye("tree"), n = u(new re({
      key: e.nodeKey,
      data: e.data,
      lazy: e.lazy,
      props: e.props,
      load: e.load,
      currentNodeKey: e.currentNodeKey,
      checkStrictly: e.checkStrictly,
      checkDescendants: e.checkDescendants,
      defaultCheckedKeys: e.defaultCheckedKeys,
      defaultExpandedKeys: e.defaultExpandedKeys,
      autoExpandParent: e.autoExpandParent,
      defaultExpandAll: e.defaultExpandAll,
      filterNodeMethod: e.filterNodeMethod
    }));
    n.value.initialize();
    const l = u(n.value.root), i = u(null), o = u(null), p = u(null), { broadcastExpanded: v } = ae(e), { dragState: E } = le({
      props: e,
      ctx: d,
      el$: o,
      dropIndicator$: p,
      store: n
    });
    se({ el$: o }, n);
    const w = G(() => {
      const { childNodes: t } = l.value;
      return !t || t.length === 0 || t.every(({ visible: r }) => !r);
    });
    c(() => e.currentNodeKey, (t) => {
      n.value.setCurrentNodeKey(t);
    }), c(() => e.defaultCheckedKeys, (t) => {
      n.value.setDefaultCheckedKey(t);
    }), c(() => e.defaultExpandedKeys, (t) => {
      n.value.setDefaultExpandedKeys(t);
    }), c(() => e.data, (t) => {
      n.value.setData(t);
    }, { deep: !0 }), c(() => e.checkStrictly, (t) => {
      n.value.checkStrictly = t;
    });
    const B = (t) => {
      if (!e.filterNodeMethod)
        throw new Error("[Tree] filterNodeMethod is required when filter");
      n.value.filter(t);
    }, T = (t) => oe(e.nodeKey, t.data), S = (t) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getNodePath");
      const r = n.value.getNode(t);
      if (!r)
        return [];
      const a = [r.data];
      let s = r.parent;
      for (; s && s !== l.value; )
        a.push(s.data), s = s.parent;
      return a.reverse();
    }, b = (t, r) => n.value.getCheckedNodes(t, r), D = (t) => n.value.getCheckedKeys(t), K = () => {
      const t = n.value.getCurrentNode();
      return t ? t.data : null;
    }, A = () => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in getCurrentKey");
      const t = K();
      return t ? t[e.nodeKey] : null;
    }, $ = (t, r) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedNodes");
      n.value.setCheckedNodes(t, r);
    }, q = (t, r) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCheckedKeys");
      n.value.setCheckedKeys(t, r);
    }, x = (t, r, a) => {
      n.value.setChecked(t, r, a);
    }, F = () => n.value.getHalfCheckedNodes(), P = () => n.value.getHalfCheckedKeys(), z = (t, r = !0) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentNode");
      k(n, d.emit, () => n.value.setUserCurrentNode(t, r));
    }, H = (t, r = !0) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in setCurrentKey");
      k(n, d.emit, () => n.value.setCurrentNodeKey(t, r));
    }, I = (t) => n.value.getNode(t), M = (t) => {
      n.value.remove(t);
    }, O = (t, r) => {
      n.value.append(t, r);
    }, L = (t, r) => {
      n.value.insertBefore(t, r);
    }, V = (t, r) => {
      n.value.insertAfter(t, r);
    }, j = (t, r, a) => {
      v(r), d.emit("node-expand", t, r, a);
    }, R = (t, r) => {
      if (!e.nodeKey)
        throw new Error("[Tree] nodeKey is required in updateKeyChild");
      n.value.updateChildren(t, r);
    };
    return N("RootTree", {
      ctx: d,
      props: e,
      store: n,
      root: l,
      currentNode: i,
      instance: J()
    }), N(he, void 0), {
      ns: g,
      store: n,
      root: l,
      currentNode: i,
      dragState: E,
      el$: o,
      dropIndicator$: p,
      isEmpty: w,
      filter: B,
      getNodeKey: T,
      getNodePath: S,
      getCheckedNodes: b,
      getCheckedKeys: D,
      getCurrentNode: K,
      getCurrentKey: A,
      setCheckedNodes: $,
      setCheckedKeys: q,
      setChecked: x,
      getHalfCheckedNodes: F,
      getHalfCheckedKeys: P,
      setCurrentNode: z,
      setCurrentKey: H,
      t: m,
      getNode: I,
      remove: M,
      append: O,
      insertBefore: L,
      insertAfter: V,
      handleNodeExpand: j,
      updateKeyChildren: R
    };
  }
});
function me(e, d, m, g, n, l) {
  const i = Q("el-tree-node");
  return y(), f("div", {
    ref: "el$",
    class: h([
      e.ns.b(),
      e.ns.is("dragging", !!e.dragState.draggingNode),
      e.ns.is("drop-not-allow", !e.dragState.allowDrop),
      e.ns.is("drop-inner", e.dragState.dropType === "inner"),
      { [e.ns.m("highlight-current")]: e.highlightCurrent }
    ]),
    role: "tree"
  }, [
    (y(!0), f(W, null, X(e.root.childNodes, (o) => (y(), Y(i, {
      key: e.getNodeKey(o),
      node: o,
      props: e.props,
      accordion: e.accordion,
      "render-after-expand": e.renderAfterExpand,
      "show-checkbox": e.showCheckbox,
      "render-content": e.renderContent,
      onNodeExpand: e.handleNodeExpand
    }, null, 8, ["node", "props", "accordion", "render-after-expand", "show-checkbox", "render-content", "onNodeExpand"]))), 128)),
    e.isEmpty ? (y(), f("div", {
      key: 0,
      class: h(e.ns.e("empty-block"))
    }, [
      Z(e.$slots, "empty", {}, () => {
        var o;
        return [
          C("span", {
            class: h(e.ns.e("empty-text"))
          }, _((o = e.emptyText) != null ? o : e.t("el.tree.emptyText")), 3)
        ];
      })
    ], 2)) : ee("v-if", !0),
    te(C("div", {
      ref: "dropIndicator$",
      class: h(e.ns.e("drop-indicator"))
    }, null, 2), [
      [ne, e.dragState.showDropIndicator]
    ])
  ], 2);
}
var be = /* @__PURE__ */ ue(fe, [["render", me], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree.vue"]]);
export {
  be as default
};

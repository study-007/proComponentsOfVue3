import { defineComponent as j, inject as B, ref as m, getCurrentInstance as z, provide as H, watch as N, nextTick as L, resolveComponent as h, withDirectives as R, openBlock as l, createElementBlock as E, normalizeClass as C, withModifiers as s, createElementVNode as P, normalizeStyle as W, createBlock as k, withCtx as y, resolveDynamicComponent as q, createCommentVNode as b, createVNode as K, Fragment as G, renderList as J, vShow as T } from "vue";
import { isFunction as Q, isString as U } from "../../../../../../../registry.npmmirror.com_@vue_shared@3.3.4/node_modules/@vue/shared/dist/shared.esm-bundler.mjs";
import X from "../../collapse-transition/index.mjs";
import { ElCheckbox as Y } from "../../checkbox/index.mjs";
import { ElIcon as Z } from "../../icon/index.mjs";
import { Loading as x, CaretRight as _ } from "../../../../../../../registry.npmmirror.com_@element-plus_icons-vue@2.1.0_vue@3.2.36/node_modules/@element-plus/icons-vue/dist/index.mjs";
import ee from "./tree-node-content.mjs";
import { getNodeKey as ne, handleCurrentChange as de } from "./model/util.mjs";
import { useNodeExpandEventBroadcast as oe } from "./model/useNodeExpandEventBroadcast.mjs";
import { dragEventsKey as ae } from "./model/useDragNode.mjs";
import te from "./model/node.mjs";
import re from "../../../_virtual/plugin-vue_export-helper.mjs";
import { useNamespace as le } from "../../../hooks/use-namespace/index.mjs";
import { debugWarn as ie } from "../../../utils/error.mjs";
const se = j({
  name: "ElTreeNode",
  components: {
    ElCollapseTransition: X,
    ElCheckbox: Y,
    NodeContent: ee,
    ElIcon: Z,
    Loading: x
  },
  props: {
    node: {
      type: te,
      default: () => ({})
    },
    props: {
      type: Object,
      default: () => ({})
    },
    accordion: Boolean,
    renderContent: Function,
    renderAfterExpand: Boolean,
    showCheckbox: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["node-expand"],
  setup(e, o) {
    const w = le("tree"), { broadcastExpanded: S } = oe(e), d = B("RootTree"), u = m(!1), c = m(!1), p = m(null), f = m(null), v = m(null), g = B(ae), i = z();
    H("NodeInstance", i), d || ie("Tree", "Can not find node's tree."), e.node.expanded && (u.value = !0, c.value = !0);
    const a = d.props.props.children || "children";
    N(() => {
      const n = e.node.data[a];
      return n && [...n];
    }, () => {
      e.node.updateChildren();
    }), N(() => e.node.indeterminate, (n) => {
      D(e.node.checked, n);
    }), N(() => e.node.checked, (n) => {
      D(n, e.node.indeterminate);
    }), N(() => e.node.expanded, (n) => {
      L(() => u.value = n), n && (c.value = !0);
    });
    const I = (n) => ne(d.props.nodeKey, n.data), F = (n) => {
      const t = e.props.class;
      if (!t)
        return {};
      let r;
      if (Q(t)) {
        const { data: V } = n;
        r = t(V, n);
      } else
        r = t;
      return U(r) ? { [r]: !0 } : r;
    }, D = (n, t) => {
      (p.value !== n || f.value !== t) && d.ctx.emit("check-change", e.node.data, n, t), p.value = n, f.value = t;
    }, M = (n) => {
      de(d.store, d.ctx.emit, () => d.store.value.setCurrentNode(e.node)), d.currentNode.value = e.node, d.props.expandOnClickNode && O(), d.props.checkOnClickNode && !e.node.disabled && $(null, {
        target: { checked: !e.node.checked }
      }), d.ctx.emit("node-click", e.node.data, e.node, i, n);
    }, A = (n) => {
      d.instance.vnode.props.onNodeContextmenu && (n.stopPropagation(), n.preventDefault()), d.ctx.emit("node-contextmenu", n, e.node.data, e.node, i);
    }, O = () => {
      e.node.isLeaf || (u.value ? (d.ctx.emit("node-collapse", e.node.data, e.node, i), e.node.collapse()) : (e.node.expand(), o.emit("node-expand", e.node.data, e.node, i)));
    }, $ = (n, t) => {
      e.node.setChecked(t.target.checked, !d.props.checkStrictly), L(() => {
        const r = d.store.value;
        d.ctx.emit("check", e.node.data, {
          checkedNodes: r.getCheckedNodes(),
          checkedKeys: r.getCheckedKeys(),
          halfCheckedNodes: r.getHalfCheckedNodes(),
          halfCheckedKeys: r.getHalfCheckedKeys()
        });
      });
    };
    return {
      ns: w,
      node$: v,
      tree: d,
      expanded: u,
      childNodeRendered: c,
      oldChecked: p,
      oldIndeterminate: f,
      getNodeKey: I,
      getNodeClass: F,
      handleSelectChange: D,
      handleClick: M,
      handleContextMenu: A,
      handleExpandIconClick: O,
      handleCheckChange: $,
      handleChildNodeExpand: (n, t, r) => {
        S(t), d.ctx.emit("node-expand", n, t, r);
      },
      handleDragStart: (n) => {
        d.props.draggable && g.treeNodeDragStart({ event: n, treeNode: e });
      },
      handleDragOver: (n) => {
        n.preventDefault(), d.props.draggable && g.treeNodeDragOver({
          event: n,
          treeNode: { $el: v.value, node: e.node }
        });
      },
      handleDrop: (n) => {
        n.preventDefault();
      },
      handleDragEnd: (n) => {
        d.props.draggable && g.treeNodeDragEnd(n);
      },
      CaretRight: _
    };
  }
}), ce = ["aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-key"], he = ["aria-expanded"];
function ue(e, o, w, S, d, u) {
  const c = h("el-icon"), p = h("el-checkbox"), f = h("loading"), v = h("node-content"), g = h("el-tree-node"), i = h("el-collapse-transition");
  return R((l(), E("div", {
    ref: "node$",
    class: C([
      e.ns.b("node"),
      e.ns.is("expanded", e.expanded),
      e.ns.is("current", e.node.isCurrent),
      e.ns.is("hidden", !e.node.visible),
      e.ns.is("focusable", !e.node.disabled),
      e.ns.is("checked", !e.node.disabled && e.node.checked),
      e.getNodeClass(e.node)
    ]),
    role: "treeitem",
    tabindex: "-1",
    "aria-expanded": e.expanded,
    "aria-disabled": e.node.disabled,
    "aria-checked": e.node.checked,
    draggable: e.tree.props.draggable,
    "data-key": e.getNodeKey(e.node),
    onClick: o[1] || (o[1] = s((...a) => e.handleClick && e.handleClick(...a), ["stop"])),
    onContextmenu: o[2] || (o[2] = (...a) => e.handleContextMenu && e.handleContextMenu(...a)),
    onDragstart: o[3] || (o[3] = s((...a) => e.handleDragStart && e.handleDragStart(...a), ["stop"])),
    onDragover: o[4] || (o[4] = s((...a) => e.handleDragOver && e.handleDragOver(...a), ["stop"])),
    onDragend: o[5] || (o[5] = s((...a) => e.handleDragEnd && e.handleDragEnd(...a), ["stop"])),
    onDrop: o[6] || (o[6] = s((...a) => e.handleDrop && e.handleDrop(...a), ["stop"]))
  }, [
    P("div", {
      class: C(e.ns.be("node", "content")),
      style: W({ paddingLeft: (e.node.level - 1) * e.tree.props.indent + "px" })
    }, [
      e.tree.props.icon || e.CaretRight ? (l(), k(c, {
        key: 0,
        class: C([
          e.ns.be("node", "expand-icon"),
          e.ns.is("leaf", e.node.isLeaf),
          {
            expanded: !e.node.isLeaf && e.expanded
          }
        ]),
        onClick: s(e.handleExpandIconClick, ["stop"])
      }, {
        default: y(() => [
          (l(), k(q(e.tree.props.icon || e.CaretRight)))
        ]),
        _: 1
      }, 8, ["class", "onClick"])) : b("v-if", !0),
      e.showCheckbox ? (l(), k(p, {
        key: 1,
        "model-value": e.node.checked,
        indeterminate: e.node.indeterminate,
        disabled: !!e.node.disabled,
        onClick: o[0] || (o[0] = s(() => {
        }, ["stop"])),
        onChange: e.handleCheckChange
      }, null, 8, ["model-value", "indeterminate", "disabled", "onChange"])) : b("v-if", !0),
      e.node.loading ? (l(), k(c, {
        key: 2,
        class: C([e.ns.be("node", "loading-icon"), e.ns.is("loading")])
      }, {
        default: y(() => [
          K(f)
        ]),
        _: 1
      }, 8, ["class"])) : b("v-if", !0),
      K(v, {
        node: e.node,
        "render-content": e.renderContent
      }, null, 8, ["node", "render-content"])
    ], 6),
    K(i, null, {
      default: y(() => [
        !e.renderAfterExpand || e.childNodeRendered ? R((l(), E("div", {
          key: 0,
          class: C(e.ns.be("node", "children")),
          role: "group",
          "aria-expanded": e.expanded
        }, [
          (l(!0), E(G, null, J(e.node.childNodes, (a) => (l(), k(g, {
            key: e.getNodeKey(a),
            "render-content": e.renderContent,
            "render-after-expand": e.renderAfterExpand,
            "show-checkbox": e.showCheckbox,
            node: a,
            accordion: e.accordion,
            props: e.props,
            onNodeExpand: e.handleChildNodeExpand
          }, null, 8, ["render-content", "render-after-expand", "show-checkbox", "node", "accordion", "props", "onNodeExpand"]))), 128))
        ], 10, he)), [
          [T, e.expanded]
        ]) : b("v-if", !0)
      ]),
      _: 1
    })
  ], 42, ce)), [
    [T, e.node.visible]
  ]);
}
var Re = /* @__PURE__ */ re(se, [["render", ue], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tree/src/tree-node.vue"]]);
export {
  Re as default
};
